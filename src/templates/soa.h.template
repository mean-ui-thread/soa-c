#ifndef <%= _.toUpper(_.snakeCase(descriptor.name)) %>_H
#define <%= _.toUpper(_.snakeCase(descriptor.name)) %>_H

<%= descriptor.headerIncludes?.map((include) => {

    let comment = include.comment ? ' /* ' + include.comment + ' */' : '';

    if (include.isLocal) {
        return `#include "${include.fileName}"${comment}`;
    } else {
        return `#include <${include.fileName}>${comment}`;
    }
  }).join('\n')
%>

#ifdef __cplusplus
extern "C" {
#endif

/* opaque handle for <%= descriptor.name %> */
typedef struct <%= descriptor.name %> { unsigned int index; } <%= descriptor.name %>_t;

<%= descriptor.soaFields.map((soaField) => {
    const soaGetterName = formatter(`${descriptor.name} get ${soaField.name}`);
    const soaSetterName = formatter(`${descriptor.name} set ${soaField.name}`);
    return (
        `/**\n` +
        ` * Getter for ${soaField.name}\n` +
        (soaField.comment ? ` * ${soaField.comment}\n` : '') +
        ` * @param handle the ${descriptor.name} instance\n` +
        ` * @return The value of ${soaField.name}\n` +
        ` * @sa ${soaSetterName}\n` +
        ` */\n` +
        `${soaField.type} ${soaGetterName}(${descriptor.name}_t handle);\n` +
        '\n' +
        `/**\n` +
        ` * Setter for ${soaField.name}\n` +
        (soaField.comment ? ` * ${soaField.comment}\n` : '') +
        ` * @param handle the ${descriptor.name} instance\n` +
        ` * @param ${soaField.name} The value of ${soaField.name}\n` +
        ` * @sa ${soaGetterName}\n` +
        ` */\n` +
        `void ${soaSetterName}(${descriptor.name}_t handle, ${soaField.type} ${soaField.name});`
    );
  }).join('\n\n')
%>

#ifdef __cplusplus
}
#endif

#endif /* <%= _.toUpper(_.snakeCase(descriptor.name)) %>_H */
 