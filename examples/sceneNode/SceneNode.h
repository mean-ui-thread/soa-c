/******************************************************************************
 * WARNING: DO NOT EDIT THIS FILE!!!
 * This header file was code-generated on Sun, 01 Oct 2023 00:28:07 GMT, using:
 *
 * ███████╗ ██████╗  █████╗        ██████╗
 * ██╔════╝██╔═══██╗██╔══██╗      ██╔════╝
 * ███████╗██║   ██║███████║█████╗██║     
 * ╚════██║██║   ██║██╔══██║╚════╝██║     
 * ███████║╚██████╔╝██║  ██║      ╚██████╗
 * ╚══════╝ ╚═════╝ ╚═╝  ╚═╝       ╚═════╝ v0.0.1
 * A CLI that generates Struct-of-Arrays (SOA) C code from a JSON descriptor 
 * file.
 *
 * By: Mean-UI-Thread - Copyright (c) 2023 - All rights reserved.
 * https://github.com/mean-ui-thread/soa-c#readme
 *
 * ----------------------------------------------------------------------------
 *
 * SceneNode, by John Smith : A nestable structure that contains transformation 
 * properties of graphical and non-graphical elements. Building block of a 
 * scene tree.
 *
 * Before including this single-file header in *one* C or C++ file to create, 
 * do the following:
 *   #define SCENE_NODE_IMPLEMENTATION
 *
 * For example, it should look like this:
 *   #include ...
 *   #include ...
 *   #define SCENE_NODE_IMPLEMENTATION
 *   #include "SceneNode.h"
 *
 * Optionally, you can define the following before including this header:
 *   #define SCENE_NODE_ALIGNMENT ...
 *   #define SCENE_NODE_ASSERT(condition) ...
 *   #define SCENE_NODE_ALIGNED_ALLOC(align, ptr) ...
 *   #define SCENE_NODE_ALIGNED_FREE(ptr) ...
 *   #define SCENE_NODE_ALIGNED_REALLOC(ptr, align, ptr) ...
 *   #define SCENE_NODE_MALLOC_USABLE_SIZE(ptr) ...
 *   #define SCENE_NODE_IMPLEMENTATION
 *   #include "SceneNode.h"
 *
 *****************************************************************************/

/******************************************************************************
 * MIT License Copyright (c) 2023 John Smith
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy 
 * of this software and associated documentation files (the "Software"), to 
 * deal in the Software without restriction, including without limitation the 
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or 
 * sell copies of the Software, and to permit persons to whom the Software is 
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice (including the next 
 * paragraph) shall be included in all copies or substantial portions of the 
 * Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
 * IN THE SOFTWARE.
 *****************************************************************************/

#ifndef SCENE_NODE_H
#define SCENE_NODE_H

#include <assert.h> /* assert() */
#include <stdint.h> /* SIZE_MAX */
#include <stddef.h> /* size_t */

#define SCENE_NODE_UNUSED SIZE_MAX

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief SceneNode Manager Structure.
 * This structure contains all the data of every SceneNode instances in a 
 * structure-of-array form.
 * @sa sceneNodeCreate
 * @sa sceneNodeGrab
 * @sa sceneNodeDrop
 * @sa sceneNodeManagerCreate
 * @sa sceneNodeManagerDestroy
 */
typedef struct
{
    float* positionX; /*!< Horizontal position of a scene node in pixel fragment unit. */
    float* positionY; /*!< Vertical position of a scene node in pixel fragment unit. */
    float* rotation; /*!< Z-rotation angle of a scene node in radians. */
    float* scaleX; /*!< Horizontal scaling of a scene node in multiplication factor. */
    float* scaleY; /*!< Vertical scaling of a scene node in multiplication factor. */
    size_t* _refCount; /*!< Instance reference counter. */
    size_t* _instanceToSoaMap; /*!< Instance to SOA index map. */
    size_t* _soaToInstanceMap; /*!< SOA to instance index map. */

    size_t _capacity; /*!<  Allocated capacity of the SceneNodeManager. Will double in capacity when the limit has been reached. */
    size_t  _count; /*!<  amount of SceneNodeManager in use */
} SceneNodeManager;

/**
 * @brief SceneNode instance.
 * @sa sceneNodeCreate
 * @sa sceneNodeCreate
 */
typedef struct {
    SceneNodeManager *manager; /* pointer to the SceneNodeManager instance */
    size_t instanceIndex; /* index to the instance map */
} SceneNode;

/**
 * @brief SceneNodeManager Instance Allocator.
 * Creates the SOA management structure instance behind the scene.
 * @sa sceneNodeManagerDestroy
 */
SceneNodeManager* sceneNodeManagerCreate(void);

/**
 * @brief SceneNodeManager Instance Deallocation
 * Destroys the SOA management structure instance behind the scene.
 * @sa sceneNodeManagerCreate
 */
void sceneNodeManagerDestroy(SceneNodeManager *manager);

/**
 * @brief SceneNode Instance Allocator.
 * This function instantiates a new SceneNode instance.
 * @sa sceneNodeGrab
 * @sa sceneNodeDrop
 */
SceneNode sceneNodeCreate(SceneNodeManager *manager);

/**
 * @brief Increments SceneNode Instance Reference Count.
 * @sa sceneNodeDrop
 */
void sceneNodeGrab(SceneNode instance);

/**
 * @brief Decrements SceneNode Instance Reference Count.
 * If the reference count reaches 0, the SceneNode instance will be destroyed.
 * @sa sceneNodeGrab
 */
void sceneNodeDrop(SceneNode instance);

/**
 * @brief Getter for positionX
 * Horizontal position of a scene node in pixel fragment unit.
 * @param instance the SceneNode instance.
 * @return The value of positionX
 * @sa sceneNodeSetPositionX
 */
inline float sceneNodeGetPositionX(SceneNode instance)
{
    assert(instance.manager);
    assert(instance.instanceIndex != SCENE_NODE_UNUSED);
    size_t soaIndex = instance.manager->_instanceToSoaMap[instance.instanceIndex];
    assert(soaIndex != SCENE_NODE_UNUSED);
    return instance.manager->positionX[soaIndex];
}

/**
 * @brief Setter for positionX
 * Horizontal position of a scene node in pixel fragment unit.
 * @param instance the SceneNode instance.
 * @return The value of positionX
 * @sa sceneNodeGetPositionX
 */
inline void sceneNodeSetPositionX(SceneNode instance, float positionX)
{
    assert(instance.manager);
    size_t soaIndex = instance.manager->_instanceToSoaMap[instance.instanceIndex];
    assert(soaIndex != SCENE_NODE_UNUSED);
    instance.manager->positionX[soaIndex] = positionX;
}

/**
 * @brief Getter for positionY
 * Vertical position of a scene node in pixel fragment unit.
 * @param instance the SceneNode instance.
 * @return The value of positionY
 * @sa sceneNodeSetPositionY
 */
inline float sceneNodeGetPositionY(SceneNode instance)
{
    assert(instance.manager);
    assert(instance.instanceIndex != SCENE_NODE_UNUSED);
    size_t soaIndex = instance.manager->_instanceToSoaMap[instance.instanceIndex];
    assert(soaIndex != SCENE_NODE_UNUSED);
    return instance.manager->positionY[soaIndex];
}

/**
 * @brief Setter for positionY
 * Vertical position of a scene node in pixel fragment unit.
 * @param instance the SceneNode instance.
 * @return The value of positionY
 * @sa sceneNodeGetPositionY
 */
inline void sceneNodeSetPositionY(SceneNode instance, float positionY)
{
    assert(instance.manager);
    size_t soaIndex = instance.manager->_instanceToSoaMap[instance.instanceIndex];
    assert(soaIndex != SCENE_NODE_UNUSED);
    instance.manager->positionY[soaIndex] = positionY;
}

/**
 * @brief Getter for rotation
 * Z-rotation angle of a scene node in radians.
 * @param instance the SceneNode instance.
 * @return The value of rotation
 * @sa sceneNodeSetRotation
 */
inline float sceneNodeGetRotation(SceneNode instance)
{
    assert(instance.manager);
    assert(instance.instanceIndex != SCENE_NODE_UNUSED);
    size_t soaIndex = instance.manager->_instanceToSoaMap[instance.instanceIndex];
    assert(soaIndex != SCENE_NODE_UNUSED);
    return instance.manager->rotation[soaIndex];
}

/**
 * @brief Setter for rotation
 * Z-rotation angle of a scene node in radians.
 * @param instance the SceneNode instance.
 * @return The value of rotation
 * @sa sceneNodeGetRotation
 */
inline void sceneNodeSetRotation(SceneNode instance, float rotation)
{
    assert(instance.manager);
    size_t soaIndex = instance.manager->_instanceToSoaMap[instance.instanceIndex];
    assert(soaIndex != SCENE_NODE_UNUSED);
    instance.manager->rotation[soaIndex] = rotation;
}

/**
 * @brief Getter for scaleX
 * Horizontal scaling of a scene node in multiplication factor.
 * @param instance the SceneNode instance.
 * @return The value of scaleX
 * @sa sceneNodeSetScaleX
 */
inline float sceneNodeGetScaleX(SceneNode instance)
{
    assert(instance.manager);
    assert(instance.instanceIndex != SCENE_NODE_UNUSED);
    size_t soaIndex = instance.manager->_instanceToSoaMap[instance.instanceIndex];
    assert(soaIndex != SCENE_NODE_UNUSED);
    return instance.manager->scaleX[soaIndex];
}

/**
 * @brief Setter for scaleX
 * Horizontal scaling of a scene node in multiplication factor.
 * @param instance the SceneNode instance.
 * @return The value of scaleX
 * @sa sceneNodeGetScaleX
 */
inline void sceneNodeSetScaleX(SceneNode instance, float scaleX)
{
    assert(instance.manager);
    size_t soaIndex = instance.manager->_instanceToSoaMap[instance.instanceIndex];
    assert(soaIndex != SCENE_NODE_UNUSED);
    instance.manager->scaleX[soaIndex] = scaleX;
}

/**
 * @brief Getter for scaleY
 * Vertical scaling of a scene node in multiplication factor.
 * @param instance the SceneNode instance.
 * @return The value of scaleY
 * @sa sceneNodeSetScaleY
 */
inline float sceneNodeGetScaleY(SceneNode instance)
{
    assert(instance.manager);
    assert(instance.instanceIndex != SCENE_NODE_UNUSED);
    size_t soaIndex = instance.manager->_instanceToSoaMap[instance.instanceIndex];
    assert(soaIndex != SCENE_NODE_UNUSED);
    return instance.manager->scaleY[soaIndex];
}

/**
 * @brief Setter for scaleY
 * Vertical scaling of a scene node in multiplication factor.
 * @param instance the SceneNode instance.
 * @return The value of scaleY
 * @sa sceneNodeGetScaleY
 */
inline void sceneNodeSetScaleY(SceneNode instance, float scaleY)
{
    assert(instance.manager);
    size_t soaIndex = instance.manager->_instanceToSoaMap[instance.instanceIndex];
    assert(soaIndex != SCENE_NODE_UNUSED);
    instance.manager->scaleY[soaIndex] = scaleY;
}





#ifdef __cplusplus
}
#endif

#endif /* SCENE_NODE_H */

#ifdef SCENE_NODE_IMPLEMENTATION

#if defined(__APPLE__)
    #include <malloc/malloc.h>
    #include <stdalign.h>
    #include <stdlib.h>
    #include <string.h>
#elif defined(__linux__)
    #include <malloc.h>
    #include <stdalign.h>
    #include <stdlib.h>
    #include <string.h>
#elif defined(_MSC_VER)
    #include <malloc.h>
#endif

#ifndef SCENE_NODE_ALIGNMENT
    #define SCENE_NODE_ALIGNMENT 64 /* Large enough for AVX-512 */
#endif

#ifndef SCENE_NODE_ASSERT
    #define SCENE_NODE_ASSERT(condition) assert(condition)
#endif

#if defined(SCENE_NODE_ALIGNED_ALLOC) && defined(SCENE_NODE_ALIGNED_FREE) && defined(SCENE_NODE_ALIGNED_REALLOC)
    /* valid */
#elif !defined(SCENE_NODE_ALIGNED_ALLOC) && !defined(SCENE_NODE_ALIGNED_FREE) && !defined(SCENE_NODE_ALIGNED_REALLOC)
    /* valid */
#else
    #error "Must define all or none of SCENE_NODE_ALIGNED_ALLOC, SCENE_NODE_ALIGNED_FREE, and SCENE_NODE_ALIGNED_REALLOC."
#endif

#ifndef SCENE_NODE_MALLOC_USABLE_SIZE
    #if defined(__APPLE__)
        #define SCENE_NODE_MALLOC_USABLE_SIZE(ptr) malloc_size(ptr)
    #elif defined(__linux__)
        #define SCENE_NODE_MALLOC_USABLE_SIZE(ptr) malloc_usable_size(ptr)
    #else
        #define SCENE_NODE_MALLOC_USABLE_SIZE(ptr)
    #endif
#endif /* SCENE_NODE_MALLOC_USABLE_SIZE */

#if !defined(SCENE_NODE_ALIGNED_FREE) && !defined(SCENE_NODE_ALIGNED_ALLOC) && !defined(SCENE_NODE_ALIGNED_REALLOC)
    #if defined(__APPLE__) || defined(__linux__)
        #define SCENE_NODE_ALIGNED_FREE(ptr) free(ptr)
        #define SCENE_NODE_ALIGNED_ALLOC(align, size) aligned_alloc(align, size)
        #define SCENE_NODE_ALIGNED_REALLOC(ptr, align, size) _sceneNodeAlignedRealloc(ptr, align, size)
    #elif defined(_MSC_VER)
        #define SCENE_NODE_ALIGNED_FREE(ptr) _aligned_free(ptr)
        #define SCENE_NODE_ALIGNED_ALLOC(align, size) _aligned_alloc(size, align)
        #define SCENE_NODE_ALIGNED_REALLOC(ptr, align, size) _aligned_realloc(ptr, size, align);
    #else
        #define SCENE_NODE_ALIGNED_FREE(ptr) free(ptr)
        #define SCENE_NODE_ALIGNED_ALLOC(align, size) malloc(size)
        #define SCENE_NODE_ALIGNED_REALLOC(ptr, align, size) realloc(ptr, size)
    #endif
#endif

#ifdef __cplusplus
extern "C" {
#endif

#if defined(__APPLE__) || defined(__linux__)
/**
 * @brief Realloc helper function for macos and linux.
 * @param ptr the pointer to the buffer to resize
 * @param align The alignment value, which must be an integer power of 2.
 * @param size The size of the requested memory allocation, which must be a multiple of align
 * @return the new reallocated buffer with its new size
 */
inline void* _sceneNodeAlignedRealloc(void* ptr, size_t align, size_t size)
{
    if ((size == 0) || (align <= alignof(max_align_t)))
    {
        return realloc(ptr, size);
    }
    size_t newSize = (size + (align - 1)) & (~(align - 1));
    void *newPtr = SCENE_NODE_ALIGNED_ALLOC(align, newSize);
    if (newPtr != NULL)
    {
        size_t oldUsableSize = SCENE_NODE_MALLOC_USABLE_SIZE(ptr);
        size_t copySize = newSize < oldUsableSize ? newSize : oldUsableSize;
        if (ptr != NULL)
            {
            memcpy(newPtr, ptr, copySize);
            free(ptr);
        }
    }
    return newPtr;
}
#endif

SceneNodeManager* sceneNodeManagerCreate(void)
{
    SceneNodeManager* manager = malloc(sizeof(SceneNodeManager));
    assert(manager);

    manager->positionX = SCENE_NODE_ALIGNED_ALLOC(SCENE_NODE_ALIGNMENT, SCENE_NODE_ALIGNMENT * sizeof(float));
    manager->positionY = SCENE_NODE_ALIGNED_ALLOC(SCENE_NODE_ALIGNMENT, SCENE_NODE_ALIGNMENT * sizeof(float));
    manager->rotation = SCENE_NODE_ALIGNED_ALLOC(SCENE_NODE_ALIGNMENT, SCENE_NODE_ALIGNMENT * sizeof(float));
    manager->scaleX = SCENE_NODE_ALIGNED_ALLOC(SCENE_NODE_ALIGNMENT, SCENE_NODE_ALIGNMENT * sizeof(float));
    manager->scaleY = SCENE_NODE_ALIGNED_ALLOC(SCENE_NODE_ALIGNMENT, SCENE_NODE_ALIGNMENT * sizeof(float));
    manager->_refCount = SCENE_NODE_ALIGNED_ALLOC(SCENE_NODE_ALIGNMENT, SCENE_NODE_ALIGNMENT * sizeof(size_t));
    manager->_instanceToSoaMap = SCENE_NODE_ALIGNED_ALLOC(SCENE_NODE_ALIGNMENT, SCENE_NODE_ALIGNMENT * sizeof(size_t));
    manager->_soaToInstanceMap = SCENE_NODE_ALIGNED_ALLOC(SCENE_NODE_ALIGNMENT, SCENE_NODE_ALIGNMENT * sizeof(size_t));
    memset(manager->_soaToInstanceMap, 0xFF, SCENE_NODE_ALIGNMENT * sizeof(size_t));
    memset(manager->_instanceToSoaMap, 0xFF, SCENE_NODE_ALIGNMENT * sizeof(size_t));
    manager->_capacity = SCENE_NODE_ALIGNMENT;
    manager->_count = 0;

    return manager;
}

void sceneNodeManagerDestroy(SceneNodeManager* manager)
{
    assert(manager);
    SCENE_NODE_ALIGNED_FREE(manager->positionX);
    SCENE_NODE_ALIGNED_FREE(manager->positionY);
    SCENE_NODE_ALIGNED_FREE(manager->rotation);
    SCENE_NODE_ALIGNED_FREE(manager->scaleX);
    SCENE_NODE_ALIGNED_FREE(manager->scaleY);
    SCENE_NODE_ALIGNED_FREE(manager->_refCount);
    SCENE_NODE_ALIGNED_FREE(manager->_instanceToSoaMap);
    SCENE_NODE_ALIGNED_FREE(manager->_soaToInstanceMap);

    free(manager);
}

SceneNode sceneNodeCreate(SceneNodeManager *manager) {
    assert(manager);
    size_t instanceIndex = 0;
    size_t soaIndex = 0;

    if(manager->_count == manager->_capacity)
    {
        manager->_capacity = manager->_capacity << 1; /* doubles the capacity */
        manager->positionX = SCENE_NODE_ALIGNED_REALLOC(manager->positionX, SCENE_NODE_ALIGNMENT, SCENE_NODE_ALIGNMENT * sizeof(float));
        manager->positionY = SCENE_NODE_ALIGNED_REALLOC(manager->positionY, SCENE_NODE_ALIGNMENT, SCENE_NODE_ALIGNMENT * sizeof(float));
        manager->rotation = SCENE_NODE_ALIGNED_REALLOC(manager->rotation, SCENE_NODE_ALIGNMENT, SCENE_NODE_ALIGNMENT * sizeof(float));
        manager->scaleX = SCENE_NODE_ALIGNED_REALLOC(manager->scaleX, SCENE_NODE_ALIGNMENT, SCENE_NODE_ALIGNMENT * sizeof(float));
        manager->scaleY = SCENE_NODE_ALIGNED_REALLOC(manager->scaleY, SCENE_NODE_ALIGNMENT, SCENE_NODE_ALIGNMENT * sizeof(float));
        manager->_refCount = SCENE_NODE_ALIGNED_REALLOC(manager->_refCount, SCENE_NODE_ALIGNMENT, SCENE_NODE_ALIGNMENT * sizeof(size_t));
        manager->_instanceToSoaMap = SCENE_NODE_ALIGNED_REALLOC(manager->_instanceToSoaMap, SCENE_NODE_ALIGNMENT, SCENE_NODE_ALIGNMENT * sizeof(size_t));
        manager->_soaToInstanceMap = SCENE_NODE_ALIGNED_REALLOC(manager->_soaToInstanceMap, SCENE_NODE_ALIGNMENT, SCENE_NODE_ALIGNMENT * sizeof(size_t));

        /* Fast Forward since we know anything before that is in-use. */
        instanceIndex = manager->_count;
        soaIndex = manager->_count;
    }

    for(; instanceIndex < manager->_capacity; ++instanceIndex)
    {
        if (manager->_soaToInstanceMap[instanceIndex] == SCENE_NODE_UNUSED) /* which means unused and available */
        {
            for(; soaIndex < manager->_capacity; ++soaIndex)
            {
                if(manager->_instanceToSoaMap[soaIndex] == SCENE_NODE_UNUSED) /* which means unused and available */
                {
                    manager->_refCount[instanceIndex] = 1;
                    manager->_instanceToSoaMap[instanceIndex] = soaIndex;
                    manager->_soaToInstanceMap[soaIndex] = instanceIndex;
                    ++manager->_count;
                    return (SceneNode){.manager = manager, .instanceIndex = instanceIndex};
                }
            }
        }
    }

    return (SceneNode){.manager = manager, .instanceIndex = instanceIndex};
}

void sceneNodeGrab(SceneNode instance)
{
    assert(instance.manager);
    assert(instance.instanceIndex != SCENE_NODE_UNUSED);
    ++instance.manager->_refCount[instance.instanceIndex];
}

void sceneNodeDrop(SceneNode instance)
{
    assert(instance.manager);
    assert(instance.instanceIndex != SCENE_NODE_UNUSED);
    if(--instance.manager->_refCount[instance.instanceIndex] == 0)
    {
        size_t soaIndex = instance.manager->_instanceToSoaMap[instance.instanceIndex];
        assert(soaIndex != SCENE_NODE_UNUSED);
        instance.manager->_instanceToSoaMap[instance.instanceIndex] = SCENE_NODE_UNUSED;
        instance.manager->_soaToInstanceMap[soaIndex] = SCENE_NODE_UNUSED;
        instance.manager = NULL;
        instance.instanceIndex = SCENE_NODE_UNUSED;
    }
}


#ifdef __cplusplus
}
#endif

#endif /* SCENE_NODE_IMPLEMENTATION */
